# ARTS2019001
week1 20190713

### Algorithm

1. 代码地址: https://github.com/ZeroMing/LeetCodeMing
2. 算法题: 415、93、306


### Review

1. A Java Fork/Join Framework By Doug Lea

> 链接地址: (http://gee.cs.oswego.edu/dl/papers/fj.pdf)

> 笔记

    1. ForkJoin框架的设计，参考了为英特尔Cilk 语言设计的work-stealing框架。工作偷取。
    主要实现技术围绕着高效的创建和管理任务队列和工作线程。
    2. Fork/Join并行方式是获取良好的并行计算性能的一种最简单同时也是最有效的设计技术。
    Fork/Join并行算法是我们所熟悉的分治算法的并行版本
    3. Fork操作将会启动一个新的并行fork/join子任务。Join操作会一直等待直到所有的子任务都结束。
    Fork/Join算法，如同其他分治算法一样，
    总是会递归的、反复的划分子任务，直到这些子任务可以用足够简单的、短小的顺序方法来执行。
    4. java.lang.Thread类（同时也包括POSIX pthreads, 这些也是Java线程所基于的基础）对Fork/Join程序来说并不是最优的选择。
    Java标准的线程框架对fork/join程序而言太笨重了
    5. 所有的fork/join任务都是轻量级执行类的实例，而不是线程实例。在Java中，独立的可执行任务必须要实现Runnable接口并重写run方法。
    在FJTask框架中，这些任务将作为子类继承FJTask而不是Thread，它们都实现了Runnable接口。
    6. Fork/jion框架的核心在于轻量级调度机制。FJTask采用了Cilk的 work-stealing 所采用的基本调度策略。
    7. 使用后进先出——LIFO用来处理每个工作线程的自己任务，但是使用先进先出——FIFO规则用于获取别的任务，
    这是一种被广泛使用的进行递归fork/join设计的一种调优手段。让
    偷取任务的线程从队列拥有者相反的方向进行操作会减少线程竞争。同样体现了递归分治算法的大任务优先策略。
    因此，更早期被偷取的任务有可能会提供一个更大的单元任务，从而使得偷取线程能够在将来进行递归分解。
    8. 双端队列。（双端队列中的元素可以从两端弹出，其限定插入和删除操作在队列的两端进行）实现双端队列的主要挑战来自于同步和他的撤销。
    9. 双端队列的元素会被多线程并发的访问，在缺乏足够同步的情况下，而且单个的Java数组元素也不能声明为volitile变量（声明成volatile的数组，其元素并不具备volatile语意），
    每个数组元素实际上都是一个固定的引用，这个引用指向了一个维护着单个volitile引用的转发对象。一开始做出这个决定主要是考虑到Java内存模型的一致性。
    但是在这个级别它所需要的间接寻址被证明在一些测试过的平台上能够提升性能。
    可能是因为访问邻近的元素而降低了缓存争用，这样内存里面的间接寻址会更快一点。
    10.



2. 这周工作任务不是很忙，和一个好朋友一起开始做一个开源项目:分布式的任务调度平台。

[后端友情链接,欢迎指正和STAR] (https://github.com/tesseract-job/tesseract-job-admin.git)
[前端友情链接,欢迎指正和STAR] (https://github.com/tesseract-job/tesseract-job-view.git)


### Tip

> 工作心经:

1. 实事求是，在工作中，不要打肿脸充胖子。我有能力，就是会，那就勇敢挑战任务；不会就认怂，不丢脸。
等工作之余去恶补，赶上来。如果非要硬上，可能会导致工期延误，在上级心中留下不好的印象，个人信心和热情受打击。得不偿失。
2. 对于需求不明确的任务，坚决不接。一个聪明高效的程序员，一定会在开始动手之前，把需求的来龙去脉都摸清楚了。
才不会掉坑、挖坑。因为你如果不明不白之中做了第一版，那好，这口锅以后就是你背了，跑不掉。要么跳槽。（亲身经历）
3. 纸眼得来终觉浅。写代码这件事，就是 practice make perfect。看懂和你可以真正写出来，是有十万八千里的差距。
不要相信自己的眼睛，要相信自己的手。
4. 线上项目如果出现接口问题。 日志先行，逻辑检查。记住一句话，我以为它是怎样的，我想它是怎样的，我猜它是怎样的，
都不及自己真真切切排查看到的。

> 技术心经:

1. 上周基于vue-element-admin、Spring Security 进行前后端权限开发，遇到一个折腾了一下午的问题。原因在此。

> 关于webpack编译es6的一个小坑

    webpack 编译es6 动态引入 import() 时不能传入变量，例如dir =’path/to/my/file.js’ ； import(dir) , 而要传入字符串 import(‘path/to/my/file.js’)，这是因为webpack的现在的实现方式不能实现完全动态。
    但一定要用变量的时候，可以通过字符串模板来提供部分信息给webpack；例如import(./path/${myFile}), 这样编译时会编译所有./path下的模块，但运行时确定myFile的值才会加载，从而实现懒加载。



### Share

技术类英文站点分享

O'Reilly ideas

原本叫O'Reilly Radar，能够阅读到Tim O'Reilly（著名的O'Reilly出版公司的创始人）和其它人讨论有关于网络、编程、开放源代码运动、知识产权、政策、Web 2.0和其它前沿科技的地方。

techdirt

技术丑闻（Techdirt）是一个话题中心，以在当前的互联网和电脑领域的热门事件上引发激烈争论而闻名。流言蜚语是它的所爱！简洁是它的特点！

lifehacker

生活骇客（Lifehacker）的座右铭表达了它的全部理念：“不要为技术而生活，要为生活而关注技术！”这个博客提供了有关于各方各面的“时间节省”小贴士，从Firefox网络浏览器的快捷操作，到来自“时间管理教”忠实信徒的谆谆教诲。

其他：

参见链接：https://blog.csdn.net/huchengxtu/article/details/2115505